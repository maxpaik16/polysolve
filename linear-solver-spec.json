[
    {
        "pointer": "/",
        "default": null,
        "type": "object",
        "optional": [
            "enable_overwrite_solver",
            "solver",
            "precond",
            "Eigen::LeastSquaresConjugateGradient",
            "Eigen::DGMRES",
            "Eigen::ConjugateGradient",
            "Eigen::BiCGSTAB",
            "Eigen::GMRES",
            "Eigen::MINRES",
            "Pardiso",
            "Hypre",
            "AMGCL",
            "Experimental"
        ],
        "doc": "Settings for the linear solver."
    },
    {
        "pointer": "/enable_overwrite_solver",
        "default": false,
        "type": "bool",
        "doc": "If solver name is not present, falls back to default"
    },
    {
        "pointer": "/solver",
        "default": "",
        "type": "string",
        "doc": "Linear solver type.",
        "options": [
            "Eigen::SimplicialLDLT",
            "Eigen::SparseLU",
            "Eigen::CholmodSupernodalLLT",
            "Eigen::UmfPackLU",
            "Eigen::SuperLU",
            "Eigen::PardisoLDLT",
            "Eigen::PardisoLLT",
            "Eigen::PardisoLU",
            "Pardiso",
            "Hypre",
            "Experimental",
            "AMGCL",
            "Eigen::LeastSquaresConjugateGradient",
            "Eigen::DGMRES",
            "Eigen::ConjugateGradient",
            "Eigen::BiCGSTAB",
            "Eigen::GMRES",
            "Eigen::MINRES"
        ]
    },
    {
        "pointer": "/precond",
        "default": "",
        "type": "string",
        "doc": "Preconditioner used if using an iterative linear solver.",
        "options": [
            "Eigen::IdentityPreconditioner",
            "Eigen::DiagonalPreconditioner",
            "Eigen::IncompleteCholesky",
            "Eigen::LeastSquareDiagonalPreconditioner",
            "Eigen::IncompleteLUT"
        ]
    },
    {
        "pointer": "/Eigen::LeastSquaresConjugateGradient",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's Least Squares Conjugate Gradient solver."
    },
    {
        "pointer": "/Eigen::DGMRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's DGMRES solver."
    },
    {
        "pointer": "/Eigen::ConjugateGradient",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's Conjugate Gradient solver."
    },
    {
        "pointer": "/Eigen::BiCGSTAB",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's BiCGSTAB solver."
    },
    {
        "pointer": "/Eigen::GMRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's GMRES solver."
    },
    {
        "pointer": "/Eigen::MINRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's MINRES solver."
    },
    {
        "pointer": "/Pardiso",
        "default": null,
        "type": "object",
        "optional": [
            "mtype"
        ],
        "doc": "Settings for the Pardiso solver."
    },
    {
        "pointer": "/Hypre",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "pre_max_iter",
            "tolerance",
            "theta",
            "nodal_coarsening",
            "interp_rbms",
            "dimension"
        ],
        "doc": "Settings for the Hypre solver."
    },
    {
        "pointer": "/AMGCL",
        "default": null,
        "type": "object",
        "optional": [
            "solver",
            "precond"
        ],
        "doc": "Settings for the AMGCL solver."
    },
    {
        "pointer": "/Eigen::LeastSquaresConjugateGradient/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Eigen::LeastSquaresConjugateGradient/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Eigen::DGMRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Eigen::DGMRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Eigen::ConjugateGradient/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Eigen::ConjugateGradient/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Eigen::BiCGSTAB/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Eigen::BiCGSTAB/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Eigen::GMRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Eigen::GMRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Eigen::MINRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Eigen::MINRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Pardiso/mtype",
        "default": 11,
        "type": "int",
        "options": [
            1,
            2,
            -2,
            3,
            4,
            -4,
            6,
            11,
            13
        ],
        "doc": "Matrix type."
    },
    {
        "pointer": "/Hypre/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Hypre/pre_max_iter",
        "default": 1,
        "type": "int",
        "doc": "Maximum number of pre iterations."
    },
    {
        "pointer": "/Hypre/tolerance",
        "default": 1e-10,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Hypre/theta",
        "default": 0.5,
        "type": "float",
        "doc": "Strong threshold."
    },
    {
        "pointer": "/Hypre/interp_rbms",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to interp rbms."
    },
    {
        "pointer": "/Hypre/nodal_coarsening",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to include nodal coarsening options."
    },
    {
        "pointer": "/Hypre/dimension",
        "default": 1,
        "type": "int",
        "doc": "Dimension of problem."
    },
    {
        "pointer": "/AMGCL/solver",
        "default": null,
        "type": "object",
        "optional": [
            "tol",
            "maxiter",
            "type"
        ],
        "doc": "Solver settings for the AMGCL."
    },
    {
        "pointer": "/AMGCL/precond",
        "default": null,
        "type": "object",
        "optional": [
            "relax",
            "class",
            "max_levels",
            "direct_coarse",
            "ncycle",
            "coarsening"
        ],
        "doc": "Preconditioner settings for the AMGCL."
    },
    {
        "pointer": "/AMGCL/solver/maxiter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/AMGCL/solver/tol",
        "default": 1e-10,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/AMGCL/solver/type",
        "default": "cg",
        "type": "string",
        "doc": "Type of solver to use."
    },
    {
        "pointer": "/AMGCL/precond/relax",
        "default": null,
        "type": "object",
        "optional": [
            "degree",
            "type",
            "power_iters",
            "higher",
            "lower",
            "scale"
        ],
        "doc": "Preconditioner settings for the AMGCL."
    },
    {
        "pointer": "/AMGCL/precond/class",
        "default": "amg",
        "type": "string",
        "doc": "Type of preconditioner to use."
    },
    {
        "pointer": "/AMGCL/precond/max_levels",
        "default": 6,
        "type": "int",
        "doc": "Maximum number of levels."
    },
    {
        "pointer": "/AMGCL/precond/direct_coarse",
        "default": false,
        "type": "bool",
        "doc": "Use direct solver for the coarsest level."
    },
    {
        "pointer": "/AMGCL/precond/ncycle",
        "default": 2,
        "type": "int",
        "doc": "Number of cycles."
    },
    {
        "pointer": "/AMGCL/precond/coarsening",
        "default": null,
        "type": "object",
        "optional": [
            "type",
            "estimate_spectral_radius",
            "relax",
            "aggr"
        ],
        "doc": "Coarsening parameters."
    },
    {
        "pointer": "/AMGCL/precond/relax/degree",
        "default": 16,
        "type": "int",
        "doc": "Degree of the polynomial."
    },
    {
        "pointer": "/AMGCL/precond/relax/type",
        "default": "chebyshev",
        "type": "string",
        "doc": "Type of relaxation to use."
    },
    {
        "pointer": "/AMGCL/precond/relax/power_iters",
        "default": 100,
        "type": "int",
        "doc": "Number of power iterations."
    },
    {
        "pointer": "/AMGCL/precond/relax/higher",
        "default": 2,
        "type": "float",
        "doc": "Higher level relaxation."
    },
    {
        "pointer": "/AMGCL/precond/relax/lower",
        "default": 0.008333333333,
        "type": "float",
        "doc": "Lower level relaxation."
    },
    {
        "pointer": "/AMGCL/precond/relax/scale",
        "default": true,
        "type": "bool",
        "doc": "Scale."
    },
    {
        "pointer": "/AMGCL/precond/coarsening/type",
        "default": "smoothed_aggregation",
        "type": "string",
        "doc": "Coarsening type."
    },
    {
        "pointer": "/AMGCL/precond/coarsening/estimate_spectral_radius",
        "default": true,
        "type": "bool",
        "doc": "Should the spectral radius be estimated."
    },
    {
        "pointer": "/AMGCL/precond/coarsening/relax",
        "default": 1,
        "type": "float",
        "doc": "Coarsening relaxation."
    },
    {
        "pointer": "/AMGCL/precond/coarsening/aggr",
        "default": null,
        "type": "object",
        "optional": [
            "eps_strong"
        ],
        "doc": "Aggregation settings."
    },
    {
        "pointer": "/AMGCL/precond/coarsening/aggr/eps_strong",
        "default": 0,
        "type": "float",
        "doc": "Aggregation epsilon strong."
    },
    {
        "pointer": "/Experimental",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "pre_max_iter",
            "tolerance",
            "theta",
            "nodal_coarsening",
            "interp_rbms",
            "dimension",
            "do_mixed_precond",
            "dss_in_middle",
            "print_conditioning",
            "use_incomplete_cholesky_precond",
            "use_absolute_tol",
            "rho",
            "bad_dof_grad_threshold",
            "select_bad_dofs_from_rhs",
            "save_grad_norms",
            "save_problem",
            "save_selected_indices"
        ],
        "doc": "Settings for the Experimental solver."
    },
    {
        "pointer": "/Experimental/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/Experimental/pre_max_iter",
        "default": 1,
        "type": "int",
        "doc": "Maximum number of pre iterations."
    },
    {
        "pointer": "/Experimental/tolerance",
        "default": 1e-10,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/Experimental/theta",
        "default": 0.5,
        "type": "float",
        "doc": "Strong threshold."
    },
    {
        "pointer": "/Experimental/interp_rbms",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to interp rbms."
    },
    {
        "pointer": "/Experimental/nodal_coarsening",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to include nodal coarsening options."
    },
    {
        "pointer": "/Experimental/dimension",
        "default": 1,
        "type": "int",
        "doc": "Dimension of problem."
    },
    {
        "pointer": "/Experimental/do_mixed_precond",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to use mixed preconditioner with direct subsolve."
    },
    {
        "pointer": "/Experimental/print_conditioning",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to print out conditioning of matrix."
    },
    {
        "pointer": "/Experimental/use_incomplete_cholesky_precond",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to use incomplete cholesky preconditioner in PCG."
    },
    {
        "pointer": "/Experimental/dss_in_middle",
        "default": true,
        "type": "bool",
        "doc": "If using the mixed preconditioner, whether or not to use dss in middle (or AMG if false)."
    },
    {
        "pointer": "/Experimental/use_absolute_tol",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to use absolute residual tolerance to check convergence."
    },
    {
        "pointer": "/Experimental/rho",
        "default": 1.01,
        "type": "float",
        "doc": "If using incomplete cholesky preconditioner, threshold used in setting sparsity pattern."
    },
    {
        "pointer": "/Experimental/bad_dof_grad_threshold",
        "default": 0.1,
        "type": "float",
        "doc": "What percentile gradient magnitude to use as a cutoff for marking a node as problematic (between 0 and 1)."
    },
    {
        "pointer": "/Experimental/select_bad_dofs_from_rhs",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to use magnitude of gradient at node to select problematic dofs."
    },
    {
        "pointer": "/Experimental/bad_dof_row_norm_threshold",
        "default": 0.1,
        "type": "float",
        "doc": "What percentile row norm magnitude to use as a cutoff for marking a node as problematic (between 0 and 1)."
    },
    {
        "pointer": "/Experimental/select_bad_dofs_from_row_norms",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to use magnitude of hessian rows for node to select problematic dofs."
    },
    {
        "pointer": "/Experimental/save_grad_norms",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to save sorted magnitude of gradient to file."
    },
    {
        "pointer": "/Experimental/save_row_norms",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to save sorted magnitude of hessian rows to file."
    },
    {
        "pointer": "/Experimental/save_problem",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to save matrix and rhs to separate files."
    },
    {
        "pointer": "/Experimental/save_selected_indices",
        "default": false,
        "type": "bool",
        "doc": "Whether or not to save the indices used in DSS to file."
    }
        
]